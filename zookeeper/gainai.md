#zookeepr 基本模型
ZooKeeper有一个分层命名空间，类似于一个**分布式文件**系统.唯一的不同是命名空间中的每一个节点能够存储数据，子节点也是. 它看起来像是文件系统，并且允许文件也是一个目录. 一个规范的、绝对的、斜杠分隔的路径来表示一个节点路径. 不存在相对路径. 任何符号只要符合以下约束条件都可以被使用:
null字符(\u000)不能在一个路径名称被使用.(这会导致C语言编程的问题.)
下列字符不能被使用，因为他们不能被很好的被展示:\u0001 - \u0019 and \u007F - \u009F.
下列字符不允许使用： \ud800 -uF8FFF, \uFFF0 - uFFFF.
"."字符可以和其他字符组合使用，但是 "." and ".."不能被单独作为一个节点和路径使用，因为Zookeeper不能使用相对路径.下面是一些无效的例子： "/a/b/./c" 或者 "/a/b/../c".
这个标识"zookeeper"是保留的.
##ZNodes
在Zookeeper数中每一个节点都被称为znode. Znodes包含一个stat数据结构，包含版本号、acl改变. sta数据结构也有时间戳. 通过版本号和时间戳Zookeeper能够检查缓存和协调更新. 每次zode的数据改变，版本号会增加. 例如，每当客户端获取数据时，会同时获取数据的版本. 当客户端执行一个更新或删除时，它必须提供要改变节点数据的版本号. 如果它提供的版本号不等于真实数据的版本号，更新将失败. (这个行为也可以被重写，更多信息看...)[tbd...]

注意
在分布式应用中，node这个词可以用来表示一台主机，一个服务，一个集群中的成员，一个客户端进程，etc. 在Zookeeper文档中，znodes表示一个数据节点. 服务表示组成Zookeeper服务的机器; quorum peers表示组成集群的机器; 客户端表示任何使用Zookeper服务的主机或进程.

一个znode是需要程序员熟悉的重要抽象概念. Znodes有几个值得注意的特征.
## 观察者
客户端能够为znodes设置观察者. zonde节点发生改变时会触发观察者并在之后移除观察者. 当观察者被触发，Zookeeper会给客户端发送一个通知.关于观察者更多的内容，可以查看ZooKeeper Watches部分.
## 数据访问
在命名空间的每个znode的数据存储操作读和写都是原子性的. 读操作读取与这个znode节点相关的全部数据，写操作更新znode的全部数据. 每个节点都有一个访问控制清单(ACL)约束了谁能进行操作.

ZooKeeper不是为了设计成一般数据库或者为大对象数据存储而做的. 相反，他是用来管理协调数据.  数据能够以配置信息、状态信息、集合点等形式存在. 各式各样分布式数据的共同点是它们都比较小. 以千字节为标准. Zookeeper客户端和服务端有一个健康检查来确保znodes节点的数据小于1M, 然而数据通常情况下会更小. 操作大的数据会导致操作花费更多的时间，会影响操作的延迟，因为需要在网络和存储媒介中传输数据需要消耗额外的时间. 处理该数据的通常模式是将该数据存储在一个大容量的存储系统，例如NFS和HDFS，然后在Zookeeper中去存储数据的保存位置.
## 临时节点
ZooKeeper也有临时节点的概念. 这些znodes存活的时间和创建这个节点的会话有效期是一样的. 当会话结束，znode会被删除. 因为这个原因，所以临时的znodes是不允许有孩子节点的.
## 顺序节点 -- 唯一名称
当创建一个znode时，你可以请求Zookeeper在路径的末尾添加一个自增计数器. 对于父节点来说这个计数器是独一无二的. 计数器的格式是%010d -- 这是一个十位数.(客户端以这种格式化来简化排序), i.e. "<path>0000000001". 看 Queue Recipe 关于这个特征使用的例子. 注意：这个计数器用来存储下一个序列号是一个4字节的数，当增加到2147483647 之后，计数器会溢出.
## Zookeeper中的时间
ZooKeeper跟踪时间的多种方式:

* Zxid

每次改变Zookeeper的状态都会接收一个zxid形式的标志.(ZooKeeper事务Id). 这里展示了所有Zookeeper变更顺序.每次改变都会获得一个独一无二的zxid，如果zxid1小于zxid2，那么zid1产生在zxid2之前.

* version

每次改变节点都会使节点的版本号之一的增加. 这三个版本号是:version (一个节点数据的变化次数), cversion (一个节点的孩子节点的变化次数), 和 aversion (一个节点ALC的变化次数).

* Ticks

当使用集群Zookeeper时，服务使用ticks作为事件的定义时间，例如状态更新、session超时、集群节点间连接超时时间. 这个tick时间仅仅间接通过最小session超时时间暴露出来. (2个tick的时间); 如果一个客户端请求session超时时间是小于最小超时时间，这个服务会告诉客户端的超时时间值等于最小超时时间.

* Real time

ZooKeeper不使用real time时间或者时钟时间，除了在创建或修改znode时将该时间放入stat结构中.
## ZooKeeper Stat Structure
每个Zookeeper的znode的stat结构由以下这些字段组成：

* czxid
znode节点创建时的事务ID.

* mzxid
znode最后修改时间的事务ID

* pzxid
znode孩子节点最后修改时的事务ID.

* ctime
znode被创建时的时间，以毫秒为时间单位.

* mtime
znode被修改时的时间，以毫秒为时间单位.

* version
znode节点数据改变的次数

* cversion
znode孩子节点改变的次数

* aversion
znode节点ACL变化的次数

* ephemeralOwner
如果这个节点是临时节点，那么这个标识znode的所属会话ID. 如果不是临时节点，那么会是0.

* dataLength
znode数据的长度

* numChildren
znode孩子节点的数量

> https://blog.csdn.net/whp1473/article/details/79620979












